<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>å‡Œå¦‚é›ªå¥³å£«åœ£è¯èŠ‚å¿«ä¹</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            /* å¹½æ·±å¤œç©ºèƒŒæ™¯ */
            background: radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%);
            font-family: 'Times New Roman', serif;
            touch-action: none; /* ä¼˜åŒ–è§¦å±ä½“éªŒ */
        }

        /* ç¥ç¦è¯­ - ä½äºå±å¹•ä¸Šæ–¹ï¼Œé¿å…é®æŒ¡æ ‘ */
        .ui-container {
            position: absolute;
            top: 15%; 
            left: 0;
            width: 100%;
            text-align: center;
            pointer-events: none; /* è®©ç‚¹å‡»ç©¿é€ */
            z-index: 100;
        }

        .main-text {
            font-size: 2.2rem;
            background: linear-gradient(135deg, #fff 0%, #ffd700 50%, #fff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: bold;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
            letter-spacing: 2px;
            animation: floatText 3s ease-in-out infinite alternate;
        }

        .sub-text {
            font-size: 1rem;
            color: #ccc;
            letter-spacing: 5px;
            margin-top: 5px;
            text-transform: uppercase;
            font-weight: 300;
        }

        @keyframes floatText {
            from { transform: translateY(0); opacity: 0.9; }
            to { transform: translateY(-10px); opacity: 1; text-shadow: 0 0 25px rgba(255, 215, 0, 0.6); }
        }

        /* åº•éƒ¨äº¤äº’æç¤º */
        .hint {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.3);
            font-size: 12px;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div class="ui-container">
        <div class="main-text">å‡Œå¦‚é›ªå¥³å£«<br>åœ£è¯èŠ‚å¿«ä¹</div>
        <div class="sub-text">Merry Christmas</div>
    </div>
    
    <div class="hint">ğŸ‘‹ æ»‘åŠ¨å±å¹•æ—‹è½¬åœ£è¯æ ‘</div>

    <canvas id="canvas"></canvas>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let w, h;
    
    // æ—‹è½¬å˜é‡
    let angleY = 0;
    let targetAngleY = 0;
    let isDragging = false;
    let startX = 0;
    let autoRotateSpeed = 0.005; // è‡ªåŠ¨æ—‹è½¬é€Ÿåº¦

    function resize() {
        w = canvas.width = window.innerWidth;
        h = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- äº¤äº’æ§åˆ¶ (æ”¯æŒé¼ æ ‡å’Œè§¦æ‘¸) ---
    const handleStart = (x) => { isDragging = true; startX = x; };
    const handleMove = (x) => {
        if (!isDragging) return;
        let delta = x - startX;
        targetAngleY += delta * 0.008; // æ‹–åŠ¨çµæ•åº¦
        startX = x;
    };
    const handleEnd = () => { isDragging = false; };

    canvas.addEventListener('mousedown', e => handleStart(e.clientX));
    canvas.addEventListener('mousemove', e => handleMove(e.clientX));
    window.addEventListener('mouseup', handleEnd);

    canvas.addEventListener('touchstart', e => handleStart(e.touches[0].clientX));
    canvas.addEventListener('touchmove', e => handleMove(e.touches[0].clientX));
    window.addEventListener('touchend', handleEnd);


    // --- ç²’å­ç³»ç»Ÿ ---
    class Particle {
        constructor() {
            this.reset();
        }

        reset() {
            // æ ‘èº«å‚æ•°
            this.h = Math.random(); // 0(é¡¶) -> 1(åº•)
            
            // åœ£è¯æ ‘å½¢çŠ¶å…¬å¼ (åœ†é”¥ä½“)
            const maxRadius = 220;
            const treeHeight = 520;
            
            // è¶Šå¾€ä¸‹åŠå¾„è¶Šå¤§ï¼Œç¨å¾®åŠ ç‚¹æ›²ç‡è®©æ ‘èƒ–ä¸€ç‚¹
            let r = Math.pow(this.h, 0.85) * maxRadius; 
            
            // éšæœºè§’åº¦
            this.angle = Math.random() * Math.PI * 2;
            
            // 3D åŸå§‹åæ ‡
            this.x = Math.cos(this.angle) * r;
            this.y = (this.h - 0.5) * treeHeight + 50; // å±…ä¸­è°ƒæ•´
            this.z = Math.sin(this.angle) * r;
            
            // å¢åŠ ä¸€ç‚¹éšæœºæ‰°åŠ¨ï¼Œæ¨¡æ‹Ÿæ ‘å¶çš„ä¸è§„åˆ™
            this.x += (Math.random()-0.5) * 10;
            this.y += (Math.random()-0.5) * 10;
            this.z += (Math.random()-0.5) * 10;

            // é¢œè‰²å®šä¹‰
            let rand = Math.random();
            if (rand > 0.92) {
                this.color = '#ff3333'; // çº¢è‰²å½©çƒ
                this.size = Math.random() * 3 + 2;
                this.isLight = true;
            } else if (rand > 0.84) {
                this.color = '#ffd700'; // é‡‘è‰²å½©çƒ
                this.size = Math.random() * 3 + 2;
                this.isLight = true;
            } else {
                // æ ‘å¶ï¼šæ·±ç»¿åˆ°å«©ç»¿çš„æ¸å˜
                let hue = 120 + Math.random() * 40; 
                let light = 20 + Math.random() * 40;
                this.color = `hsl(${hue}, 70%, ${light}%)`;
                this.size = Math.random() * 2 + 0.5;
                this.isLight = false;
            }

            // é—ªçƒåŠ¨ç”»å‚æ•°
            this.blinkPhase = Math.random() * Math.PI;
            this.blinkSpeed = 0.02 + Math.random() * 0.04;
        }

        draw(cx, cy, rotation, time) {
            // ç»•Yè½´æ—‹è½¬
            let cos = Math.cos(rotation);
            let sin = Math.sin(rotation);
            
            let rx = this.x * cos - this.z * sin;
            let rz = this.z * cos + this.x * sin;

            // é€è§†æŠ•å½±
            let fov = 350;
            let scale = fov / (fov + rz);
            
            if (scale < 0) return; // å‰”é™¤èƒŒé¢

            let x2d = cx + rx * scale;
            let y2d = cy + this.y * scale;
            let size2d = this.size * scale;

            // å‘¼å¸/é—ªçƒæ•ˆæœ
            let alpha = 1;
            if (this.isLight) {
                // å½©ç¯é—ªçƒæ˜æ˜¾
                alpha = 0.6 + 0.4 * Math.sin(time * this.blinkSpeed + this.blinkPhase);
                // å½©ç¯åŠ å…‰æ™•
                ctx.globalAlpha = 0.4 * alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(x2d, y2d, size2d * 2.5, 0, Math.PI * 2); // å…‰æ™•å¤§ä¸€ç‚¹
                ctx.fill();
            } else {
                // æ ‘å¶å¾®å¾®å¿½æ˜å¿½æš—
                alpha = 0.8 + 0.2 * Math.sin(time * 0.02 + this.blinkPhase);
            }

            ctx.globalAlpha = alpha;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(x2d, y2d, size2d, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }
    }

    // --- é¡¶éƒ¨3Dçˆ±å¿ƒ ---
    class Heart {
        constructor() {
            this.points = [];
            // ç”Ÿæˆçˆ±å¿ƒç‚¹é˜µ
            for(let i=0; i<100; i++) {
                let t = i * 0.15;
                let x = 16 * Math.pow(Math.sin(t), 3);
                let y = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                this.points.push({x, y, z: (Math.random()-0.5)*5});
            }
            this.yOffset = -230; // æ ‘é¡¶é«˜åº¦
        }

        draw(cx, cy, rotation, time) {
            let beat = 1 + Math.sin(time * 4) * 0.12; // å¿ƒè·³å¹…åº¦
            
            ctx.fillStyle = "#ff0055";
            
            this.points.forEach(p => {
                // 1. ç¼©æ”¾ï¼ˆå¿ƒè·³ï¼‰
                let px = p.x * beat * 1.5;
                let py = p.y * beat * 1.5;
                let pz = p.z;

                // 2. æ—‹è½¬ï¼ˆéšæ ‘ä¸€èµ·è½¬ï¼‰
                let cos = Math.cos(rotation);
                let sin = Math.sin(rotation);
                let rx = px * cos - pz * sin;
                let rz = pz * cos + px * sin;

                // 3. æŠ•å½±
                let fov = 350;
                let scale = fov / (fov + rz);
                let x2d = cx + rx * scale;
                let y2d = cy + (py + this.yOffset) * scale;

                ctx.beginPath();
                ctx.arc(x2d, y2d, 2.5 * scale, 0, Math.PI * 2);
                ctx.fill();
            });
        }
    }

    // --- é›ªèŠ±ç³»ç»Ÿ ---
    class Snow {
        constructor() {
            this.reset(true);
        }
        reset(initial = false) {
            this.x = (Math.random() - 0.5) * w;
            this.y = initial ? (Math.random() - 0.5) * h : -h/2;
            this.z = (Math.random() - 0.5) * 500; // æ·±åº¦
            this.size = Math.random() * 2 + 1;
            this.speed = 1 + Math.random() * 2;
        }
        draw(cx, cy) {
            this.y += this.speed;
            if (this.y > h/2) this.reset(); // åˆ°åº•éƒ¨é‡ç½®

            // é›ªèŠ±ä¹Ÿè¦é€è§†ï¼Œæ‰æœ‰å‰åå±‚æ¬¡æ„Ÿ
            let fov = 350;
            let scale = fov / (fov + this.z);
            if (scale < 0) return;

            let x2d = cx + this.x * scale;
            let y2d = cy + this.y; // é›ªèŠ±åªåœ¨Yè½´ä¸‹è½ï¼Œä¸éšæ ‘æ—‹è½¬

            ctx.fillStyle = `rgba(255, 255, 255, ${Math.min(0.8, scale)})`;
            ctx.beginPath();
            ctx.arc(x2d, y2d, this.size * scale, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    // --- åˆå§‹åŒ– ---
    let particles = [];
    let snowFlakes = [];
    let heart = new Heart();

    function init() {
        particles = [];
        snowFlakes = [];
        // 1200ä¸ªç²’å­ç»„æˆçš„èŒ‚å¯†æ ‘
        for (let i = 0; i < 1200; i++) {
            particles.push(new Particle());
        }
        // 200ç‰‡é›ªèŠ±
        for (let i = 0; i < 200; i++) {
            snowFlakes.push(new Snow());
        }
    }
    init();

    // --- åŠ¨ç”»å¾ªç¯ ---
    let time = 0;
    function animate() {
        ctx.clearRect(0, 0, w, h);

        const cx = w / 2;
        const cy = h / 2 + 50;
        time += 0.015;

        // æ—‹è½¬æƒ¯æ€§é€»è¾‘
        if (!isDragging) {
            targetAngleY += autoRotateSpeed;
        }
        // å¹³æ»‘è¿‡æ¸¡
        angleY += (targetAngleY - angleY) * 0.1;

        // 1. ç»˜åˆ¶é›ªèŠ±
        snowFlakes.forEach(s => s.draw(cx, cy));

        // 2. ç»˜åˆ¶æ ‘ (æ··åˆæ¨¡å¼è®©ç¯å…‰æ›´äº®)
        ctx.globalCompositeOperation = 'lighter';
        particles.forEach(p => p.draw(cx, cy, angleY, time));
        
        // 3. ç»˜åˆ¶çˆ±å¿ƒ
        heart.draw(cx, cy, angleY, time);
        
        ctx.globalCompositeOperation = 'source-over';

        requestAnimationFrame(animate);
    }
    animate();

</script>
</body>
</html>

